# -*- coding: utf-8 -*-
"""MinesweeperV2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_cQ_KBNGyufk21wRk0CTd8BKzylovdQE
"""

# -*- coding: utf-8 -*-
import random
import queue
import math

class Square:

  def __init__(self, row=0, col=0, mine=False, clue=0, minesAround=0, safeAround=0, hiddenAround=0, visible=None):  

    self.row=row
    self.col=col
    self.mine = mine
    self.clue = clue
    self.minesAround=minesAround
    self.safeAround=safeAround
    self.hiddenAround=hiddenAround
    self.visible = visible

  def getMine(self):
    return self.mine

  def setMine(self, mine=True):
    self.mine = mine
    return

  def getClue(self):
    return self.clue

  def setClue(self, clue):
    self.clue = clue
    return

  def getVisible(self):
    return self.visible

  def setVisible(self, visible):
    self.visible = visible
    return

  def __str__(self):
    if self.visible == None:
      return "-"
    if not self.getVisible():
      return str(self.clue)
    if self.getMine():
      return "M"
    return str(self.clue)

#Creates board
def generateBoard(d, n):
  board = [[Square() for x in range(d)] for x in range(d)]
  
  x = 0
  while (n > x):
    i = random.randint(0, d-1)
    j = random.randint(0, d-1)
    if (board[i][j].getMine() == False):
        board[i][j].setMine(True)
        x+=1
  
  for i in range(d):
     for j in range(d):
       board[i][j].setClue(checkSurrounding(board, i, j))

  return board

#Get info on neigbors
def checkSurrounding(board, i, j):
  clue = 0
  visibleMineCount=0
  visibleSafeSpace=0
  neighbors=0
  for x in range(i-1, i+2):
    for y in range(j-1, j+2):
      if (x >= 0 and y >= 0):
        if (x < len(board) and y < len(board)):
            neighbors=neighbors+1
            if (board[x][y].getMine()):
                clue += 1
                if(board[x][y].getVisible()==True):
                    visibleMineCount+=1
            elif (board[x][y].getVisible()==True):
                    visibleSafeSpace=visibleSafeSpace+1
  return (clue,neighbors,visibleMineCount,visibleSafeSpace)

#Display board
def printBoard(board):
  for x in range(len(board)):
     for y in range(len(board)):
       print(str(board[x][y]), end=" ")
     print("\n")
  print("\n")

#Get list of hidden neigbors
def getNewNeighbors(board, i, j):
  ret = []
  
  for x in range(i-1, i+2):
    for y in range(j-1, j+2):
      if (x != i or y != j):
        if (x >= 0 and y >= 0):
          if (x < len(board) and y < len(board)):
            if (board[x][y].getVisible() == None):
              ret.append((x, y))

  return ret

#Get list of revealed neigbors
def getRevealedNeighbors(board, i, j):
  ret = []
  
  for x in range(i-1, i+2):
    for y in range(j-1, j+2):
      if (x != i or y != j):
        if (x >= 0 and y >= 0):
          if (x < len(board) and y < len(board)):
            if ((board[x][y].getVisible() == True) and not (board[x][y].getMine())):
              ret.append((x, y))

  return ret

#Updates each cell with known info
def updateBoardKnowledge(board,n):
    dim=len(board)
    for row in range(0,dim):
        for col in range(0,dim):
            clue,neighbors,visibleMineCount,visibleSafeSpace=checkSurrounding(board,row,col)
            board[row][col].clue=clue
            board[row][col].minesAround=visibleMineCount
            board[row][col].safeAround=visibleSafeSpace
            board[row][col].hiddenAround=neighbors-visibleMineCount-visibleSafeSpace

def basicAgent(d, n):
  board = generateBoard(d, n)
  bombCount = 0 
  visited=[]
  dim=len(board)
  boardChanged=False

  while bombCount < n:
    boardChanged=False
    printBoard(board)
    updateBoardKnowledge(board,n)
    #Search revealed squares to see if neighbors can be solved
    for (row,col) in visited:
        if (board[row][col].getMine()):
          continue
        clue=board[row][col].clue
        revealedMines=board[row][col].minesAround
        hiddenNeighbors=board[row][col].hiddenAround
        safeNeighbors=board[row][col].safeAround
        totalNeighbors=revealedMines+safeNeighbors+hiddenNeighbors
        
        print("ROW-COL: "+str(row)+", "+str(col)+", "+str(revealedMines))

        #Case all neighbors are mines
        if(clue-revealedMines==hiddenNeighbors):
            hiddenList=getNewNeighbors(board,row,col)
            for (i,j) in hiddenList:
                if((i,j) not in visited):
                    print("Flag mine on: "+str(i)+", "+str(j))
                    bombCount+=1
                    board[i][j].setVisible(True)
                    visited.append((i,j))
                    boardChanged=True
            
        #Case all neighbors are safe
        elif (totalNeighbors-clue-safeNeighbors==hiddenNeighbors):
            hiddenList=getNewNeighbors(board,row,col)
            for (i,j) in hiddenList:
                if ((i,j) not in visited):
                    print("Reveal: "+str(i)+", "+str(j))
                    board[i][j].setVisible(True)
                    visited.append((i,j))
                    boardChanged=True

        if(boardChanged):
            break

    #If no conclusive decision choose random
    if not boardChanged:
        i = random.randint(0, len(board)-1)
        j = random.randint(0, len(board)-1)
        while((i,j) in visited):
            i = random.randint(0, len(board)-1)
            j = random.randint(0, len(board)-1)
        print("Randomly Select: "+str(i)+", "+str(j))
        board[i][j].setVisible(True)
        if board[i][j].getMine():
            bombCount += 1
        visited.append((i,j))
  printBoard(board)

def advancedAgent(d, n):
  board = generateBoard(d, n)
  bombCount = 0 
  visited=[]
  dim=len(board)
  boardChanged=False

  while bombCount < n:
    boardChanged=False
    printBoard(board)
    updateBoardKnowledge(board,n)
    #Search revealed squares to see if neighbors can be solved
    for (row,col) in visited:
        if (board[row][col].getMine()):
          continue
        clue=board[row][col].clue
        revealedMines=board[row][col].minesAround
        hiddenNeighbors=board[row][col].hiddenAround
        safeNeighbors=board[row][col].safeAround
        totalNeighbors=revealedMines+safeNeighbors+hiddenNeighbors
        
        print("ROW-COL: "+str(row)+", "+str(col)+", "+str(revealedMines))

        #Case all neighbors are mines
        if (clue-revealedMines==hiddenNeighbors):
            hiddenList=getNewNeighbors(board,row,col)
            for (i,j) in hiddenList:
                if((i,j) not in visited):
                    print("Flag mine on: "+str(i)+", "+str(j))
                    bombCount+=1
                    board[i][j].setVisible(True)
                    visited.append((i,j))
                    boardChanged=True
            
        #Case all neighbors are safe
        elif (totalNeighbors-clue-safeNeighbors==hiddenNeighbors):
            hiddenList=getNewNeighbors(board,row,col)
            for (i,j) in hiddenList:
                if((i,j) not in visited):
                    print("Reveal: "+str(i)+", "+str(j))
                    board[i][j].setVisible(True)
                    visited.append((i,j))
                    boardChanged=True
        
        #Use inference to solve remaining spaces
        else:
          hiddenList=getNewNeighbors(board,row,col)
          revealedNeighbors = getRevealedNeighbors(board,row,col)
          for (i,j) in revealedNeighbors:
            neighborHiddenList = getNewNeighbors(board,i,j)
            uncommonNeighborsA = []
            uncommonNeighborsB = []
            commonNeighbors = []
            for (x,y) in hiddenList:
              if ((i,j) not in visited):
                if ((x,y) not in board[i][j].hiddenAround):
                  uncommonNeighborsA.append((x,y))
                else:
                  commonNeighbors.append((x,y))
            for (x,y) in neighborHiddenList:
              if ((i,j) not in visited):
                if ((x,y) not in hiddenList):
                  uncommonNeighborsB.append((x,y))

            #All uncommon neighbors are mines
            if (abs(clue - board[i][j].getClue()) == len(uncommonNeighborsA)):
              if (len(uncommonNeighborsB) == 0 and len(uncommonNeighborsA) > 0):
                for (x, y) in uncommonNeighborsA:
                  print("Infer Flag mine on: "+str(x)+", "+str(y))
                  bombCount+=1
                  board[x][y].setVisible(True)
                  visited.append((x,y))
                  boardChanged=True
            if (abs(clue - board[i][j].getClue()) == len(uncommonNeighborsB)):
              if (len(uncommonNeighborsA) == 0 and len(uncommonNeighborsB) > 0):
                for (x, y) in uncommonNeighborsB:
                  print("Infer Flag mine on: "+str(x)+", "+str(y))
                  bombCount+=1
                  board[x][y].setVisible(True)
                  visited.append((x,y))
                  boardChanged=True

            #All uncommon neighbors are clear
            if (abs(clue - board[i][j].getClue()) == 0):
              if (len(uncommonNeighborsB) == 0 and len(uncommonNeighborsA) > 0):
                for (x, y) in uncommonNeighborsA:
                  print("Infer Reveal: "+str(i)+", "+str(j))
                  board[x][y].setVisible(True)
                  visited.append((x,y))
                  boardChanged=True
            if (abs(clue - board[i][j].getClue()) == 0):
              if (len(uncommonNeighborsA) == 0 and len(uncommonNeighborsB) > 0):
                for (x, y) in uncommonNeighborsB:
                  print("Infer Reveal: "+str(i)+", "+str(j))
                  board[x][y].setVisible(True)
                  visited.append((x,y))
                  boardChanged=True
        #Select by lowest probability of mine
        if (boardChanged):
            break

    #If no conclusive decision choose random
    if not boardChanged:
        i = random.randint(0, len(board)-1)
        j = random.randint(0, len(board)-1)
        while((i,j) in visited):
            i = random.randint(0, len(board)-1)
            j = random.randint(0, len(board)-1)
        print("Randomly Select: "+str(i)+", "+str(j))
        board[i][j].setVisible(True)
        if board[i][j].getMine():
            bombCount += 1
        visited.append((i,j))
  printBoard(board)

def main():
    #FOR TESTING
    #board = generateBoard(5, 3)
    #printBoard(board)
    #basicAgent(9, 5)
    advancedAgent(9, 25)

if __name__=="__main__":
    main()